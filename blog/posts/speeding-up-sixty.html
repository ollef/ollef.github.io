<!DOCTYPE html>
<html lang="en"> 
<head profile="http://www.w3.org/2005/10/profile">
    <meta charset="UTF-8">
    <meta name="description" content="Optimising Sixty, the new Sixten compiler">
    <meta name="author" content="Olle Fredriksson">
    <meta name=viewport content="width=device-width, initial-scale=1">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@ollfredo">
<meta name="twitter:creator" content="@ollfredo">
<meta name="twitter:title" content="Speeding up the Sixty compiler">
    <meta name="twitter:description" content="Optimising Sixty, the new Sixten compiler">
    <meta name="twitter:image" content="https://ollef.github.io/blog/images/speeding-up-sixty/9-d5bad6f606450d0a2c8926072e7b4845d982b81f-threadscope.png">
    <title>Speeding up the Sixty compiler | Olle Fredriksson&#39;s blog</title>
    <link rel="icon" type="image/png" href="/blog/images/favicon.png">
    <link rel="stylesheet" href="/blog/css/style.css">
    <link rel="stylesheet" href="/blog/css/syntax.css">
</head>
<body>
    <header>
        <nav>
            <a href="/blog/">
                Home
            </a>
        </nav>
    </header>

<div id="page">
    <div class="wrapper">
        <div class="masthead">
            <span class="title">
                Speeding up the Sixty compiler
            </span>

            <img class="post-image" src="/blog/images/speeding-up-sixty/9-d5bad6f606450d0a2c8926072e7b4845d982b81f-threadscope.png">

            <span class="byline">by Olle Fredriksson</span>

            <span class="date">2020-03-06</span>

            <div class="metadata">
            </div>
        </div>
    </div>
    <article class="post">
        <h2 id="background">Background</h2>
<p>I'm working on a reimplementation of <a href="https://github.com/ollef/sixten">Sixten</a>, a dependently typed programming language that supports unboxed data. The reimplementation currently lives in a separate repository, and is called <a href="https://github.com/ollef/sixty">Sixty</a>, though the intention is that it going to replace Sixten eventually. The main reason for reimplementing it was to try out some implementation techniques to make the type checker faster, inspired by András Kovács' <a href="https://github.com/AndrasKovacs/smalltt">smalltt</a>.</p>
<p>In this post I'd like to show some optimisations that I did, guided by profiling. I will also show the workflow and tools that I use when profiling Haskell code.</p>
<h2 id="a-benchmark">A benchmark</h2>
<p>I was curious to see how Sixty would handle programs with many modules. The problem is that no one has ever written any large programs in the Sixten language so far.</p>
<p>As a substitute, I added a command to generate nonsense programs of a given size. The programs that are used in this post consist of just over 10 000 lines divided into 100 modules that all look like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">module</span> <span class="dt">Module60</span> exposing (<span class="op">..</span>)</span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">import</span> <span class="dt">Module9</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">import</span> <span class="dt">Module24</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">import</span> <span class="dt">Module35</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">import</span> <span class="dt">Module16</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="kw">import</span> <span class="dt">Module46</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="kw">import</span> <span class="dt">Module37</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="kw">import</span> <span class="dt">Module50</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="kw">import</span> <span class="dt">Module47</span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="kw">import</span> <span class="dt">Module46</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="kw">import</span> <span class="dt">Module3</span></span>
<span id="cb1-13"><a href="#cb1-13"></a></span>
<span id="cb1-14"><a href="#cb1-14"></a>f1 <span class="op">:</span> <span class="dt">Type</span></span>
<span id="cb1-15"><a href="#cb1-15"></a>f1 <span class="ot">=</span> Module46.f10 <span class="ot">-&gt;</span> Module46.f20</span>
<span id="cb1-16"><a href="#cb1-16"></a></span>
<span id="cb1-17"><a href="#cb1-17"></a>f2 <span class="op">:</span> <span class="dt">Type</span></span>
<span id="cb1-18"><a href="#cb1-18"></a>f2 <span class="ot">=</span> Module50.f24 <span class="ot">-&gt;</span> Module47.f13</span>
<span id="cb1-19"><a href="#cb1-19"></a></span>
<span id="cb1-20"><a href="#cb1-20"></a>[<span class="op">...</span>]</span>
<span id="cb1-21"><a href="#cb1-21"></a></span>
<span id="cb1-22"><a href="#cb1-22"></a>f30 <span class="op">:</span> <span class="dt">Type</span></span>
<span id="cb1-23"><a href="#cb1-23"></a>f30 <span class="ot">=</span> Module37.f4 <span class="ot">-&gt;</span> Module24.f24</span></code></pre></div>
<p>Each module is about 100 lines of code, of which a third or so are newlines, and has thirty definitions that refer to definitions from other modules. The definitions are simple enough to be type checked very quickly, so the benchmark will make us focus our attention on parts of the compiler other than the type checker. I'd also like to write about the type checker itself, but will save that for another post.</p>
<h2 id="profiling">Profiling</h2>
<p>I use three main tools to try to identify bottlenecks and other things to improve:</p>
<ul>
<li><p><a href="http://www.haskellforall.com/2016/05/a-command-line-benchmark-tool.html">bench</a> is a replacement for the Unix <code>time</code> command that I use to get more reliable timings, which is especially useful for comparing the speed of a program before and after some change.</p></li>
<li><p>GHC's built-in profiling support, which gives us a detailed breakdown of where time is spent when running the program.</p>
<p>When using Stack, we can build with profiling by issuing:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1"></a><span class="ex">stack</span> install --profile</span></code></pre></div>
<p>Then we can run the program with profiling enabled:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1"></a><span class="ex">sixty</span> check +RTS -p</span></code></pre></div>
<p>This produces a file <code>sixty.prof</code> that contains the profiling information.</p>
<p>I also really like to use <a href="https://github.com/fpco/ghc-prof-flamegraph">ghc-prof-flamegraph</a> to turn the profiling output into a flamegraph:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1"></a><span class="ex">ghc-prof-flamegraph</span> sixty.prof</span></code></pre></div></li>
<li><p><a href="https://wiki.haskell.org/ThreadScope">Threadscope</a> is a visual tool for debugging the parallelism in a Haskell program. It also shows when the garbage collector runs, so can be used when tuning garbage collector parameters.</p></li>
</ul>
<h2 id="baseline-and-initial-profiling">Baseline and initial profiling</h2>
<p>The baseline used in this post starts on <a href="https://github.com/ollef/sixty/tree/29094e006d4c88f51d744b0fd26f3e2e18af3ce0">this commit</a>.</p>
<p>At this point we get the following time to run <code>sixty check</code> in the 100 module project on my machine:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: right;">Time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Baseline</td>
<td style="text-align: right;">1.30 s</td>
</tr>
</tbody>
</table>
<p>Here's a flamegraph of the profiling output at this point:</p>
<p><a href="../images/speeding-up-sixty/0-29094e006d4c88f51d744b0fd26f3e2e18af3ce0.svg"><img src="../images/speeding-up-sixty/0-29094e006d4c88f51d744b0fd26f3e2e18af3ce0.svg" /></a></p>
<p>Two things stick out to me in the flamegraph:</p>
<ul>
<li>Parsing takes about 45 % of the time.</li>
<li>Operations on <a href="https://hackage.haskell.org/package/dependent-map"><code>Data.Dependent.Map</code></a> take about 15 % of the time, and a large part of that is calls to <code>Query.gcompare</code> when the map is doing key comparisons during lookups and insertions.</li>
</ul>
<p>Here's what a run looks like in ThreadScope:</p>
<p><a href="../images/speeding-up-sixty/0-29094e006d4c88f51d744b0fd26f3e2e18af3ce0-threadscope.png"><img src="../images/speeding-up-sixty/0-29094e006d4c88f51d744b0fd26f3e2e18af3ce0-threadscope.png" /></a></p>
<p>Here's a more zoomed in ThreadScope picture:</p>
<p><a href="../images/speeding-up-sixty/0-29094e006d4c88f51d744b0fd26f3e2e18af3ce0-threadscope-detail.png"><img src="../images/speeding-up-sixty/0-29094e006d4c88f51d744b0fd26f3e2e18af3ce0-threadscope-detail.png" /></a></p>
<p>I note the following in the ThreadScope output:</p>
<ul>
<li>One core is doing almost all of the work, with other cores only occasionally performing very short tasks.</li>
<li>Garbage collection runs extremely often and takes just over 20 % of the time.</li>
</ul>
<h2 id="optimisation-1-better-rts-flags">Optimisation 1: Better RTS flags</h2>
<p>As we saw in the ThreadScope output, garbage collection ran often and took a large part of the total runtime of the type checker.</p>
<p>In <a href="https://github.com/ollef/sixty/tree/f8d4ee7ee0d3d617c6d30401592f5639be60b14a">this commit</a> I most notably introduce the RTS option <code>-A50m</code>, which sets the default allocation area size used by the garbage collector to 50 MB, instead of the default 1 MB, which means that GC can run less often, potentially at the cost of worse cache behaviour and memory use. The value <code>50m</code> was found to be the best on my machine by experimentation.</p>
<p>The result of this change is this:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: right;">Time</th>
<th style="text-align: right;">Delta</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Baseline</td>
<td style="text-align: right;">1.30 s</td>
<td style="text-align: right;"></td>
</tr>
<tr class="even">
<td>RTS flags</td>
<td style="text-align: right;">1.08 s</td>
<td style="text-align: right;">-17 %</td>
</tr>
</tbody>
</table>
<p>A look at the ThreadScope output shows that the change has a very noticeable effect of decreasing the number of garbage collections:</p>
<p><a href="../images/speeding-up-sixty/1-f8d4ee7ee0d3d617c6d30401592f5639be60b14a-threadscope.png"><img src="../images/speeding-up-sixty/1-f8d4ee7ee0d3d617c6d30401592f5639be60b14a-threadscope.png" /></a></p>
<p>Also note that the proportion of time used by the GC went from 20 % to 3 %.</p>
<h2 id="optimisation-2-a-couple-of-rock-library-improvements">Optimisation 2: A couple of Rock library improvements</h2>
<p><a href="https://github.com/ollef/rock">Rock</a> is a library that's used to implement query-based compilation in Sixty. I made two improvements to it to get these timings:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: right;">Time</th>
<th style="text-align: right;">Delta</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Baseline</td>
<td style="text-align: right;">1.30 s</td>
<td style="text-align: right;"></td>
</tr>
<tr class="even">
<td>RTS flags</td>
<td style="text-align: right;">1.08 s</td>
<td style="text-align: right;">-17 %</td>
</tr>
<tr class="odd">
<td>Rock</td>
<td style="text-align: right;">0.613 s</td>
<td style="text-align: right;">-43 %</td>
</tr>
</tbody>
</table>
<p>The changes made were:</p>
<ul>
<li>Using <code>IORef</code>s and atomic operations instead of <code>MVar</code>s: Rock uses a cache, which is potentially accessed and updated from different threads, to e.g. keep track of what queries have already been executed. Before this change this state was stored in an <code>MVar</code>, but since it's only doing fairly simple updates, the atomic operations of <code>IORef</code> are sufficient.</li>
<li>Being a bit more clever about the automatic parallelisation: At this point in time Rock used a <a href="https://github.com/facebook/Haxl">Haxl</a>-like automatic parallelisation scheme, running queries done in an <code>Applicative</code> context in parallel. The change here is to only trigger parallel query execution if both queries are not already cached. Before this change even the cache lookup part of the queries was done in parallel, which is likely far too fine-grained to pay off.</li>
</ul>
<p>We can see quite clearly in ThreadScope that the parallelisation has a seemingly good effect for part of the runtime, but not all of it:</p>
<p><a href="../images/speeding-up-sixty/2-54b87689f345173dbed3510a396641cd8c5e43f2-threadscope.png"><img src="../images/speeding-up-sixty/2-54b87689f345173dbed3510a396641cd8c5e43f2-threadscope.png" /></a></p>
<h2 id="optimisation-3-manual-query-parallelisation">Optimisation 3: Manual query parallelisation</h2>
<p>To improve the parallelism, I removed the automatic parallelism support from the Rock library, and started doing it manually instead.</p>
<p>The following results are from simply processing all input modules in parallel, using a pooling to keep the number of threads the same as the number of threads on the machine it's run on:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: right;">Time</th>
<th style="text-align: right;">Delta</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Baseline</td>
<td style="text-align: right;">1.30 s</td>
<td style="text-align: right;"></td>
</tr>
<tr class="even">
<td>RTS flags</td>
<td style="text-align: right;">1.08 s</td>
<td style="text-align: right;">-17 %</td>
</tr>
<tr class="odd">
<td>Rock</td>
<td style="text-align: right;">0.613 s</td>
<td style="text-align: right;">-43 %</td>
</tr>
<tr class="even">
<td>Manual parallelisation</td>
<td style="text-align: right;">0.451 s</td>
<td style="text-align: right;">-26 %</td>
</tr>
</tbody>
</table>
<p>Being able to do this is an advantage of using a query-based architecture. The modules can be processed in any order, and any non-processed dependencies that are missing are processed and cached on a need basis.</p>
<p>ThreadScope shows that the CPU core utilisation is improved, even though the timings aren't as much better as one might expect from seeing the change:</p>
<p><a href="../images/speeding-up-sixty/4-7ca773e347dae952d4c7249a0310f10077a2474b-threadscope.png"><img src="../images/speeding-up-sixty/4-7ca773e347dae952d4c7249a0310f10077a2474b-threadscope.png" /></a></p>
<h2 id="optimisation-4-parser-lookahead">Optimisation 4: Parser lookahead</h2>
<p>Here's an experiment that only helped a little. I noticed that parsing took quite a large proportion of the total time spent, about 15 %, which can be seen in the top-right part of the flamegraph:</p>
<p><a href="../images/speeding-up-sixty/4-7ca773e347dae952d4c7249a0310f10077a2474b.svg"><img src="../images/speeding-up-sixty/4-7ca773e347dae952d4c7249a0310f10077a2474b.svg" /></a></p>
<p>The parser is written using parsing combinators, and the "inner loop" of e.g. the term parser is a choice between a bunch of different alternatives. Something like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="ot">term ::</span> <span class="dt">Parser</span> <span class="dt">Term</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>term <span class="ot">=</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>  parenthesizedTerm    <span class="co">-- (t)</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>  <span class="op">&lt;|&gt;</span> letExpression    <span class="co">-- let x = t in t</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>  <span class="op">&lt;|&gt;</span> caseExpression   <span class="co">-- case t of branches</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>  <span class="op">&lt;|&gt;</span> lambdaExpression <span class="co">-- \x. t</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>  <span class="op">&lt;|&gt;</span> forallExpression <span class="co">-- forall x. t</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>  <span class="op">&lt;|&gt;</span> var              <span class="co">-- x</span></span></code></pre></div>
<p>These alternatives are tried in order in the parser, which means that to reach e.g. the <code>forall</code> case, the parser will have tried to parse the first token of each of the four preceding alternatives. But note that the first character of each alternative rules out all other cases, save for (sometimes) the <code>var</code> case.</p>
<p>So the idea was to rewrite the parser like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">term ::</span> <span class="dt">Parser</span> <span class="dt">Term</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>term <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>  firstChar <span class="ot">&lt;-</span> lookAhead anyChar</span>
<span id="cb6-4"><a href="#cb6-4"></a>  <span class="kw">case</span> firstChar <span class="kw">of</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>    <span class="ch">&#39;(&#39;</span> <span class="ot">-&gt;</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>      parenthesizedTerm</span>
<span id="cb6-7"><a href="#cb6-7"></a></span>
<span id="cb6-8"><a href="#cb6-8"></a>    <span class="ch">&#39;l&#39;</span> <span class="ot">-&gt;</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>      letExpression</span>
<span id="cb6-10"><a href="#cb6-10"></a>      <span class="op">&lt;|&gt;</span> var</span>
<span id="cb6-11"><a href="#cb6-11"></a></span>
<span id="cb6-12"><a href="#cb6-12"></a>    <span class="ch">&#39;c&#39;</span> <span class="ot">-&gt;</span></span>
<span id="cb6-13"><a href="#cb6-13"></a>      caseExpression</span>
<span id="cb6-14"><a href="#cb6-14"></a>      <span class="op">&lt;|&gt;</span> var</span>
<span id="cb6-15"><a href="#cb6-15"></a></span>
<span id="cb6-16"><a href="#cb6-16"></a>    <span class="ch">&#39;\\&#39;</span> <span class="ot">-&gt;</span></span>
<span id="cb6-17"><a href="#cb6-17"></a>      lambdaExpression</span>
<span id="cb6-18"><a href="#cb6-18"></a></span>
<span id="cb6-19"><a href="#cb6-19"></a>    <span class="ch">&#39;f&#39;</span> <span class="ot">-&gt;</span></span>
<span id="cb6-20"><a href="#cb6-20"></a>      forallExpression</span>
<span id="cb6-21"><a href="#cb6-21"></a>      <span class="op">&lt;|&gt;</span> var</span>
<span id="cb6-22"><a href="#cb6-22"></a></span>
<span id="cb6-23"><a href="#cb6-23"></a>    _ <span class="ot">-&gt;</span></span>
<span id="cb6-24"><a href="#cb6-24"></a>      var</span></code></pre></div>
<p>Now we just have to look at the first character to rule out the first four alternatives when parsing a <code>forall</code>.</p>
<p>Here are the results:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: right;">Time</th>
<th style="text-align: right;">Delta</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Baseline</td>
<td style="text-align: right;">1.30 s</td>
<td style="text-align: right;"></td>
</tr>
<tr class="even">
<td>RTS flags</td>
<td style="text-align: right;">1.08 s</td>
<td style="text-align: right;">-17 %</td>
</tr>
<tr class="odd">
<td>Rock</td>
<td style="text-align: right;">0.613 s</td>
<td style="text-align: right;">-43 %</td>
</tr>
<tr class="even">
<td>Manual parallelisation</td>
<td style="text-align: right;">0.451 s</td>
<td style="text-align: right;">-26 %</td>
</tr>
<tr class="odd">
<td>Parser lookahead</td>
<td style="text-align: right;">0.442 s</td>
<td style="text-align: right;">-2 %</td>
</tr>
</tbody>
</table>
<p>Not great, but it's something.</p>
<h2 id="optimisation-5-dependent-hashmap">Optimisation 5: Dependent hashmap</h2>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: right;">Time</th>
<th style="text-align: right;">Delta</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Baseline</td>
<td style="text-align: right;">1.30 s</td>
<td style="text-align: right;"></td>
</tr>
<tr class="even">
<td>RTS flags</td>
<td style="text-align: right;">1.08 s</td>
<td style="text-align: right;">-17 %</td>
</tr>
<tr class="odd">
<td>Rock</td>
<td style="text-align: right;">0.613 s</td>
<td style="text-align: right;">-43 %</td>
</tr>
<tr class="even">
<td>Manual parallelisation</td>
<td style="text-align: right;">0.451 s</td>
<td style="text-align: right;">-26 %</td>
</tr>
<tr class="odd">
<td>Parser lookahead</td>
<td style="text-align: right;">0.442 s</td>
<td style="text-align: right;">-2 %</td>
</tr>
<tr class="even">
<td>Dependent hashmap</td>
<td style="text-align: right;">0.257 s</td>
<td style="text-align: right;">-42 %</td>
</tr>
</tbody>
</table>
<p><a href="../images/speeding-up-sixty/5-8ea6700415f1c46fb300571382ef438ae6082e8e.svg"><img src="../images/speeding-up-sixty/5-8ea6700415f1c46fb300571382ef438ae6082e8e.svg" /></a> <a href="../images/speeding-up-sixty/6-722533c5d71871ca1aa6235fe79a53f33da99c36.svg"><img src="../images/speeding-up-sixty/6-722533c5d71871ca1aa6235fe79a53f33da99c36.svg" /></a></p>
<h2 id="optimisation-6-readert-based-rock-library">Optimisation 6: <code>ReaderT</code>-based Rock library</h2>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: right;">Time</th>
<th style="text-align: right;">Delta</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Baseline</td>
<td style="text-align: right;">1.30 s</td>
<td style="text-align: right;"></td>
</tr>
<tr class="even">
<td>RTS flags</td>
<td style="text-align: right;">1.08 s</td>
<td style="text-align: right;">-17 %</td>
</tr>
<tr class="odd">
<td>Rock</td>
<td style="text-align: right;">0.613 s</td>
<td style="text-align: right;">-43 %</td>
</tr>
<tr class="even">
<td>Manual parallelisation</td>
<td style="text-align: right;">0.451 s</td>
<td style="text-align: right;">-26 %</td>
</tr>
<tr class="odd">
<td>Parser lookahead</td>
<td style="text-align: right;">0.442 s</td>
<td style="text-align: right;">-2 %</td>
</tr>
<tr class="even">
<td>Dependent hashmap</td>
<td style="text-align: right;">0.257 s</td>
<td style="text-align: right;">-42 %</td>
</tr>
<tr class="odd">
<td><code>ReaderT</code> in Rock</td>
<td style="text-align: right;">0.245 s</td>
<td style="text-align: right;">-5 %</td>
</tr>
</tbody>
</table>
<p><a href="../images/speeding-up-sixty/7-048d2cec50e9994a0b159a2383580e3df5dd2a7e.svg"><img src="../images/speeding-up-sixty/7-048d2cec50e9994a0b159a2383580e3df5dd2a7e.svg" /></a></p>
<h2 id="optimisation-7-separate-lexer">Optimisation 7: Separate lexer</h2>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: right;">Time</th>
<th style="text-align: right;">Delta</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Baseline</td>
<td style="text-align: right;">1.30 s</td>
<td style="text-align: right;"></td>
</tr>
<tr class="even">
<td>RTS flags</td>
<td style="text-align: right;">1.08 s</td>
<td style="text-align: right;">-17 %</td>
</tr>
<tr class="odd">
<td>Rock</td>
<td style="text-align: right;">0.613 s</td>
<td style="text-align: right;">-43 %</td>
</tr>
<tr class="even">
<td>Manual parallelisation</td>
<td style="text-align: right;">0.451 s</td>
<td style="text-align: right;">-26 %</td>
</tr>
<tr class="odd">
<td>Parser lookahead</td>
<td style="text-align: right;">0.442 s</td>
<td style="text-align: right;">-2 %</td>
</tr>
<tr class="even">
<td>Dependent hashmap</td>
<td style="text-align: right;">0.257 s</td>
<td style="text-align: right;">-42 %</td>
</tr>
<tr class="odd">
<td><code>ReaderT</code> in Rock</td>
<td style="text-align: right;">0.245 s</td>
<td style="text-align: right;">-5 %</td>
</tr>
<tr class="even">
<td>Separate lexer</td>
<td style="text-align: right;">0.154 s</td>
<td style="text-align: right;">-37 %</td>
</tr>
</tbody>
</table>
<p><a href="../images/speeding-up-sixty/8-11c46c5b03f26a66347d5f387bd4cdfd5f6de4a2.svg"><img src="../images/speeding-up-sixty/8-11c46c5b03f26a66347d5f387bd4cdfd5f6de4a2.svg" /></a></p>
<h2 id="optimisation-8-faster-hashing">Optimisation 8: Faster hashing</h2>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: right;">Time</th>
<th style="text-align: right;">Delta</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Baseline</td>
<td style="text-align: right;">1.30 s</td>
<td style="text-align: right;"></td>
</tr>
<tr class="even">
<td>RTS flags</td>
<td style="text-align: right;">1.08 s</td>
<td style="text-align: right;">-17 %</td>
</tr>
<tr class="odd">
<td>Rock</td>
<td style="text-align: right;">0.613 s</td>
<td style="text-align: right;">-43 %</td>
</tr>
<tr class="even">
<td>Manual parallelisation</td>
<td style="text-align: right;">0.451 s</td>
<td style="text-align: right;">-26 %</td>
</tr>
<tr class="odd">
<td>Parser lookahead</td>
<td style="text-align: right;">0.442 s</td>
<td style="text-align: right;">-2 %</td>
</tr>
<tr class="even">
<td>Dependent hashmap</td>
<td style="text-align: right;">0.257 s</td>
<td style="text-align: right;">-42 %</td>
</tr>
<tr class="odd">
<td><code>ReaderT</code> in Rock</td>
<td style="text-align: right;">0.245 s</td>
<td style="text-align: right;">-5 %</td>
</tr>
<tr class="even">
<td>Separate lexer</td>
<td style="text-align: right;">0.154 s</td>
<td style="text-align: right;">-37 %</td>
</tr>
<tr class="odd">
<td>Faster hashing</td>
<td style="text-align: right;">0.146 s</td>
<td style="text-align: right;">-5 %</td>
</tr>
</tbody>
</table>
<p><a href="../images/speeding-up-sixty/9-d5bad6f606450d0a2c8926072e7b4845d982b81f.svg"><img src="../images/speeding-up-sixty/9-d5bad6f606450d0a2c8926072e7b4845d982b81f.svg" /></a> <a href="../images/speeding-up-sixty/9-d5bad6f606450d0a2c8926072e7b4845d982b81f-threadscope.png"><img src="../images/speeding-up-sixty/9-d5bad6f606450d0a2c8926072e7b4845d982b81f-threadscope.png" /></a></p>
<h2 id="conclusion">Conclusion</h2>
    </article>

</div>

<footer>
    <div class="social-links">
        <div class="social-link-wrapper">
            <a class="social-link" href="https://github.com/ollef">
                <img src="/blog/images/github-logo.svg" alt="Github profile"/>
            </a>
        </div>
        <div class="social-link-wrapper">
            <a class="social-link" href="https://twitter.com/ollfredo">
                <img src="/blog/images/twitter-logo.svg" alt="Twitter profile"/>
            </a>
        </div>
    </div>
    <div id="copyright">&copy; 2020 <a href="mailto:fredriksson.olle@gmail.com">Olle Fredriksson</a> — <a href="/blog/atom.xml">Feed</a></div>

    Built using <a href="https://github.com/ChrisPenner/slick">slick</a> ❤️
</footer>

<script src="/blog/js/main.js"></script>
</body>
</html>
